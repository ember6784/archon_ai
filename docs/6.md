# Kernel Integration: Detailed Design

## Integration Point Decision

**Recommended: Option A — Kernel as Middleware**

All OpenClaw execution calls are wrapped by a thin middleware that routes through the Archon Kernel. OpenClaw core code is not modified — only the execution entry point is intercepted.

---

## Middleware Implementation

```python
# archon/kernel_middleware.py
from typing import Any, Dict, Callable
import logging
from enterprise.rbac import RBACSystem
from mat.circuit_breaker import CircuitBreaker
from mat.debate_pipeline import DebatePipeline

logger = logging.getLogger(__name__)

class ArchonMiddleware:
    def __init__(
        self,
        rbac: RBACSystem,
        circuit_breaker: CircuitBreaker,
        debate_pipeline: DebatePipeline,
        fast_path_threshold: float = 0.3
    ):
        self.rbac = rbac
        self.circuit_breaker = circuit_breaker
        self.debate_pipeline = debate_pipeline
        self.fast_path_threshold = fast_path_threshold

    def wrap_execution(self, openclaw_exec: Callable) -> Callable:
        async def wrapped(operation: str, payload: Dict, context: Dict, agent_id: str) -> Any:
            risk = self._estimate_risk(operation, payload)

            if risk <= self.fast_path_threshold:
                logger.info(f"Fast path: {operation} (risk={risk:.2f})")
                return await openclaw_exec(operation, payload, context)

            if not self.rbac.has_permission(agent_id, operation):
                raise PermissionError("No permission")

            if not self.circuit_breaker.is_allowed(operation):
                raise RuntimeError("Circuit open")

            if risk > 0.5:
                verdict = await self.debate_pipeline.run_debate(operation, payload, context, agent_id)
                if verdict["verdict"] != "APPROVED":
                    raise PermissionError(f"Debate rejected: {verdict['reason']}")

            return await openclaw_exec(operation, payload, context)

        return wrapped

    def _estimate_risk(self, operation: str, payload: Dict) -> float:
        if "exec" in operation or "write" in operation or "delete" in operation:
            return 0.8
        if "network" in operation:
            return 0.6
        return 0.2
```

---

## Execution Kernel: Validation Steps

**Order: fail-fast, cheapest checks first**

1. **RBAC** — Can the agent perform this operation? (in-memory lookup)
2. **Circuit Breaker** — Is the autonomy level sufficient?
3. **Resource limits** — Is the agent within CPU/memory quota?
4. **Intent Contract pre-conditions** — Rules-based pre-check
5. **Debate Pipeline** — For high-risk operations (async, expensive)
6. **Execution Contract** — Final structural validation
7. **Execute** — Trigger the registered predefined operation
8. **Post-condition invariants** — Verify state after execution

```python
# archon/kernel.py
from typing import Dict, Any
from mat.debate_pipeline import DebatePipeline

class ValidationResult:
    def __init__(self, approved: bool, reason: str = ""):
        self.approved = approved
        self.reason = reason

class ExecutionKernel:
    async def validate(
        self,
        operation: str,
        payload: Dict,
        context: Dict,
        agent_id: str,
        risk_threshold: float = 0.5
    ) -> ValidationResult:
        if not self.rbac.has_permission(agent_id, operation):
            return ValidationResult(False, "no_permission")

        if not self.circuit_breaker.is_allowed(operation):
            return ValidationResult(False, "autonomy_level")

        if not self.resource_limits.check(agent_id):
            return ValidationResult(False, "limits_exceeded")

        pre_check = self.intent_contract.check_pre(operation, payload, context)
        if not pre_check:
            return ValidationResult(False, "pre_condition_failed")

        risk = self.estimate_risk(operation, payload)
        if risk > risk_threshold:
            verdict = await self.debate_pipeline.run(operation, payload, context)
            if not verdict.approved:
                return ValidationResult(False, "debate_rejected")

        if not self.execution_contract.validate(operation, payload):
            return ValidationResult(False, "contract_violation")

        return ValidationResult(True)
```

---

## Trust Boundary Enforcement

The trust boundary runs exactly at the Kernel. Everything above (agents, LLMs) is **untrusted**. Everything below (environment, OS) is **semi-trusted**.

To prevent bypass:

| Mechanism | Layer | Purpose |
|-----------|-------|---------|
| Proxy pattern | Application | Agents see only proxy, never direct tools |
| AST rewriting | Application | Remove `eval`, `exec`, `__import__` from agent code |
| Docker namespaces | OS | Process isolation |
| seccomp whitelist | OS | Syscall restriction |
| Network namespaces | OS | Prevent unauthorized network access |

---

## Intent Contract: Hybrid Approach

**JSON** for declarative configuration, **Python** for dynamic evaluation:

```python
# archon/intent_contract.py
from typing import List, Dict, Callable
from pathlib import Path

class IntentContract:
    def __init__(self, pre: List[str], post: List[str], invariants: List[str]):
        self.pre = [self._str_to_checker(p) for p in pre]
        self.post = [self._str_to_checker(p) for p in post]
        self.invariants = [self._str_to_checker(i) for i in invariants]

    def _str_to_checker(self, rule: str) -> Callable:
        if rule == "file_exists":
            return lambda ctx: Path(ctx["file"]).exists()
        if rule == "not_in_core_path":
            return lambda ctx: "/core/" not in ctx.get("path", "")
        return lambda ctx: True

    def check_pre(self, context: Dict) -> bool:
        return all(c(context) for c in self.pre)

def load_contract(json_data: Dict) -> IntentContract:
    return IntentContract(
        pre=json_data["pre_conditions"],
        post=json_data["post_conditions"],
        invariants=json_data["invariants"]
    )
```

---

## Handling OpenClaw Updates

Since OpenClaw is an external dependency, upstream changes can break the integration.

**Mitigation strategy:**
- Use Option A (middleware) — changes are isolated to a single wrap point
- Maintain integration tests that run against the wrapped execution engine
- Pin OpenClaw version in `package.json`; upgrade deliberately with test verification
- Never patch OpenClaw source directly (Option C) — this creates unsustainable maintenance debt
